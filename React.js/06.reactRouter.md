# React Router

React Router is the standard library for client-side routing in React applications. React is focused solely on building user interfaces and does not have a built-in routing solution. This means that to handle navigation between different "pages" or views in a Single-Page Application (SPA), you need an external library like React Router.

Instead of a user's browser sending a request to a server for a new HTML page every time they click a link, React Router intercepts the request and dynamically renders the appropriate components on the client side. This provides a fast, seamless user experience without a full page reload.





## Loader
In React Router v6.4+, a loader is a function you attach to a route that runs before the route renders. Its job is to fetch or prepare the data the routeâ€™s component needs.

Think of it like: â€œWhen the user navigates to this route, what data do I need to load first?â€

ğŸ”‘ Key points about loaders

Defined on a route object (in createBrowserRouter, createRoutesFromElements, etc.).

Run before rendering the routeâ€™s element.

Return data (object, array, etc.) which is made available via the useLoaderData() hook.

If the loader throws an error, React Router automatically routes to an errorElement.

ğŸ›  Example
```jsx
import {
  createBrowserRouter,
  RouterProvider,
  Route,
  useLoaderData,
} from "react-router-dom";

// loader function: fetch user data
async function usersLoader() {
  const res = await fetch("/api/users");
  if (!res.ok) throw new Response("Failed to load users", { status: res.status });
  return res.json();
}

// component that consumes loader data
function UsersPage() {
  const users = useLoaderData() as { id: number; name: string }[];
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// define routes
const router = createBrowserRouter([
  {
    path: "/users",
    element: <UsersPage />,
    loader: usersLoader,
    errorElement: <p>Something went wrong.</p>,
  },
]);

export default function App() {
  return <RouterProvider router={router} />;
}
```

ğŸ“¦ Loader lifecycle

User navigates to /users.

React Router calls usersLoader().

If success â†’ passes data to the route â†’ useLoaderData() reads it.

If error â†’ routeâ€™s errorElement renders.

ğŸš€ Benefits

Data fetching happens before render (no loading spinners by default).

Automatic caching & revalidation built-in.

Pairs with actions (for mutations like POST/PUT/DELETE).

ğŸ‘‰ Do you want me to also explain how loaders handle caching & revalidation (like with useRevalidator and <Link reloadDocument={false}>) or just keep it at this â€œcore usageâ€ level?